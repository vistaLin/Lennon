#算法二：排序

- 最经典的、最常用的：**冒泡排序、插入排序、选择排序、归并排序、快速排序、计数排序、基数排序、桶排序。**
- 根据时间复杂度分为三类：
 - O(n^2):冒泡、 **插入** 、选择，插入排序重点掌握，只需要一次赋值，而冒泡三次，选择排序平均复杂度为O（n^2），适合小规模数据。
 - O(nlogn):**快排**、归并，适合大规模的数据排序。
 - O(n):桶、计数、基数，这三种排序算法也叫**线行排序**（Linear Sort）


排序算法执行效率分析，从几个方面衡量：
1. 最好情况、最坏情况、平均情况时间复杂度。
2. 时间复杂度的系数、常数 、低阶。
3. 比较次数和交换（或移动）次数。

**排序算法的内存消耗：**空间复杂度为O(1)的排序算法，都叫**原地排序**（Sorted in place）. 
**排序算法的稳定性：**，如果待排序的序列中存在值相等的元素，经过排序之后，相等元素之间原有的先后顺序不变，那么就叫**稳定的排序算法**，如果前后顺序发生变化，那么对应的排序算法就叫作**不稳定的排序算法**。

##1.冒泡排序（Bubble Sort）

- **冒泡排序只会操作相邻的两个数据。每次冒泡操作都会对相邻的两个元素比较，一次冒泡至少一个元素移动到它应该在的位置（一次冒泡代表比较了未排序的所有元素），重复n次，就完成了n个数据的排序。**
- 优化：当一次冒泡操作没有数据交换，说明已经完全有序，不需要继续执行后序的冒泡操作。
- 冒泡排序是空间复杂度为O(1)的原地排序算法，也是稳定的排序算法，做好的时间复杂度为O(n),最坏的时间复杂度为O(n^2),平均时间复杂度也为O(n^2).
- 可以通过**有序度**和**逆序度**两个概念来分析平均时间复杂度，满有序度-有序度就是需要交换的次数。
 - **有序度**是数组中有序关系的元素对的个数，有序元素对：a[i] <= a[j], 如果i < j。如果一个数组完全有序，那么就是**n*(n-1)/2**,称为**满有序度**。
 - **逆序度**和有序度正好想法，**逆序度=满有序度 - 有序度**。

##2.插入排序（Insertion Sort）

- 插入排序是将数组中的数据分为两个区间，**已排序区间**和**未排序区间**，初始已排序区间只有一个元素，在去未排序的区间的元素在已排序区间找到合适的位置将其插入，并保证已排序区间数据一直有序。
- 插入排序也包含两种操作，**元素的比较**和**元素的移动**，移动的次数也等于逆序度。
- 插入排序是原地排序算法，也是稳定的排序算法，最好时间复杂度为O(n),最坏和平均时间复杂度都是O(n^2)。

##3.选择排序（Selection Sort）

- **选择排序**每次会从未排序区间中找到最小的元素，将其放到已排序区间的末尾，并且是直接交换最小元素和已排序区间末尾的元素，所以是一种不稳定排序。
- 选择排序空间复杂度为 O(1)，是一种原地排序算法，是一种不稳定排序。选择排序的最好情况时间复杂度、最坏情况和平均情况时间复杂度都为 O(n2)。

##4.归并排序（Merge Sort）

- **核心思想**：如果需要排序一个数组，先把数组从中间分成前后两部分，然后在对前后两部分分别排序，再将排序好的两部分合并在一起。每次合并操作都需要申请往外的内存空间，但是合并完成临时开辟的内存空间就被释放掉了。
- 归并排序使用的是**分治思想，分治是一种解决问题的处理思想，递归是一种编程技巧**，分治算法一般都是使用递归来实现的。
- 归并排序是**一个稳定的排序算法，时间复杂度为O(nlogn),但是空间复杂度为O(n),不是一个原地排序**。所以没有快排使用的那么广泛。

##5.快速排序（Quick Sort）

**快排的思想：**排序数组中下标从p到r之间的一组数据，我们选择p到r之间的任意一个数据作为pivot(分区点)，遍历p到r，将小于pivot放到左边，大于pivot放到右边，将pivot放到中间，使用分支和递归的思想，知道递归排序小标区间缩小为1，就说明数据有序了。
归并排序的处理过程是**由下到上**的，快排则是**由上到下**的。
 
快排最好和平均时间复杂度都是**O(nlogn)**，最坏可能退化为O(n^2),是一种**原地排序**，但是**不是稳定排序

优化快排： 快排最坏的时间复杂度是O(n^2),主要原因是因为分区点选的不够合理，最理想的分区点是被分开的的两个分区中的数据差不多。常用的分区算法：
 - 三数取中法：从首、中、尾分别取出一个数，对比大小，取三个数的中间值作为分区点，数据规模大可以“五数区中”或者“十数取中”
 - 随机法：随机选择一个元素作为分区点，退化到最糟糕的时间复杂度概率也不大。
 
##6.桶排序（Bucket Sort）
 
**核心思想：**将要排序的数据分成到几个有序的桶里，每个桶里的数据在单独进行排序，每个桶排完序在按照顺序取出，组成的序列就是有序的。

**桶排序的限制性：**排序的数据需要很容易划分到m个桶，桶与桶之间有着天然的大小顺序，并且各个桶之间的分布是比较均匀的，划分不均匀极端会退化到O(nlogn)的排序算法。

**桶排序比较适合用在外部排序中**，外部排序就是数据存储在外部磁盘中，数据量大，内存有限，无法全部加载到内存，就可以划分外部数据直到可以加载到内存。

##7.计数排序（Counting Sort）

- **计数排序是桶排序的一种特殊情况**，当要排序n个数据，所处的范围不大，比如最大值为k，就把数据划分为k个桶。

**计数排序只能用在数据范围不大的场景中，如果数据范围 k 比要排序的数据 n 大很多，就不适合用计数排序了。而且，计数排序只能给非负整数排序，如果要排序的数据是其他类型的，要将其在不改变相对大小的情况下，转化为非负整数。**

##8.基数排序（Radix Sort）

**基数排序对要排序的数据是有要求的，需要可以分割出独立的“位”来比较，而且位之间有递进的关系，如果 a 数据的高位比 b 数据大，那剩下的低位就不用比较了。除此之外，每一位的数据范围不能太大，要可以用线性排序算法来排序，否则，基数排序的时间复杂度就无法做到 O(n) 了。**
