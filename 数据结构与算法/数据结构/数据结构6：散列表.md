#数据结构6：散列表（Hash Table）

散列表的英文叫“Hash Table”，我们平时也叫它“哈希表”或者“Hash 表”

**散列表用的是数组支持按照下标随机访问数据的特性，所以散列表其实就是数组的一种扩展，由数组演化而来。可以说，如果没有数组，就没有散列表。**

其中，参赛选手的编号我们叫做**键**（key）或者**关键字**。我们用它来标识一个选手。我们把参赛编号转化为数组下标的映射方法就叫作**散列函数**（或“Hash 函数”“哈希函数”），而散列函数计算得到的值就叫作**散列值**（或“Hash 值”“哈希值”）。

散列表用的就是数组支持按照下标随机访问的时候，时间复杂度是 O(1) 的特性。我们通过散列函数把元素的键值映射为下标，然后将数据存储在数组中对应下标的位置。当我们按照键值查询元素时，我们用同样的散列函数，将键值转化数组下标，从对应的数组下标的位置取数据。

##散列冲突
**散列冲突：**不同的key对应的散列值都不一样散列函数基本不可能，所以不同的key找到hash表的同一个槽，就是散列冲突。
解决散列冲突通过有两类：**开放寻址法（open addressing）和链表法（chaining）**

###开放寻址法

- 开放寻址法：出现散列冲突，就重新探测一个空闲位置，将其插入。
- 探测方法有**线性探测（Linear Probing）**,当某个数据经过散列函数散列之后，存储位置已经被占用，那么久从当前位置开始，依次往后查找，查看是否有空闲位置，直到找到为止。
- 查找通过散列函数获取到的键查值，如果没找到顺序遍历到空闲位置还没有，那么久说明要找的元素没有在散列表中。
- 删除元素要标记为delete，探测遇到delete继续往下探测。
- 除了线性探测还可以使用**二次探测**和**双重散列**，一个是步长为平方。一个是使用一组散列函数。
- **装载因子**（load factor）来表示空位的多少，散列表的装载因子=填入表中的元素个数/散列表的长度，装载因子越大，说明空闲位置越少，冲突越多，散列表的性能会下降。

###链表法

链表法是一种更加常用的散列冲突解决办法，相比开放寻址法，它要简单很多。在散列表中，每个“桶（bucket）”或者“槽（slot）”会对应一条链表。

##散列表的设计

**散列函数的设计不能太复杂， 散列函数生成的值要尽可能随机并且均匀分布。**

**装载因子过大了可以动态扩容，为避免一次性搬移可以扩容后插入一次搬移一个数据**

**当数据量比较小、装载因子小的时候，适合采用开放寻址法。基于链表的散列冲突处理方法比较适合存储大对象、大数据量的散列表，而且，比起开放寻址法，它更加灵活，支持更多的优化策略，比如用红黑树代替链表。**

##hash表和链表的混合使用

我们使用双向链表存储数据，链表中的每个结点处理存储数据（data）、前驱指针（prev）、后继指针（next）之外，还新增了一个特殊的字段 hnext。这个 hnext 有什么作用呢？

因为我们的散列表是通过链表法解决散列冲突的，所以每个结点会在两条链中。一个链是刚刚我们提到的**双向链表**，另一个链是散列表中的**拉链。前驱和后继指针是为了将结点串在双向链表中，hnext 指针是为了将结点串在散列表的拉链中。**

通过这种散列表+双向链表的模式，就可以实现删除、查找、添加一个数据的时候时间复杂度为O(1)

**LinkedHashMap 是通过双向链表和散列表这两种数据结构组合实现的。LinkedHashMap 中的“Linked”实际上是指的是双向链表，并非指用链表法解决散列冲突。**