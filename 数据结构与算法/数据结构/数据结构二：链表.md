数据结构二：链表

常见的三种缓存策略：
 - **先进先出策略FIFO(First In, First Out)**
 - **最少使用策略LFU(Least Frequently Used)**
 - **最近最少使用策略LRU(Least Recently Used)**
 
链表通过”指针“将一组**零散的内存块**串联起来使用。


最常见的三种链表结构：**单链表、双向链表和循环链表**

##单链表

内存块称为链表的**“结点”**，为了将所有的结点串起来，每个链表的结点除了存储数据之外，还需要记录链上的下一个结点的地址，把这个记录下个结点地址的指针叫作**后续指针next。**

链表的第一个结点叫作**头结点**，最后一个结点叫作**尾结点**，头结点记录链表的基地址，而尾结点指向一个**空地址NULL**。

因为链表的不需要保持内存数据的连续性，所以插入或者删除一个数据时间复杂度为O(1)，同样因为内存数据的不连续性，只能通过指针一个结点一个结点依次遍历找到查询的结点，所以查询复杂度为O(n).

##循环链表

- **循环链表是一种特殊的单链表**,就是单链表尾结点指针指向空地址，而循环链表的尾结点指针指向链表的头结点，适合处理数据具有环形结构特点的数据。

##双向链表

**双向链表支持两个方向，有后续指针next指向后面的结点，还有一个前驱指针prev指向前面的结点**。

**存储同样的数据，双向链表比单链表占用更多的内存空间，双向链表可以支持O(1)时间复杂度的情况下找到前驱结点，🙆双向链表在某些情况下的插入、删除等操作比单链表简单、高效。**

##删除链表数据

删除的两种情况
 - 删除节点中“值等于某个给定值”的结点
 - 删除给定指针指向的结点

链表的单纯的删除操作时间复杂度是O(1),但第一种情况遍历查找对应的时间复杂度为O(n),所以删除值等于定值的结点对应的链表操作的总时间复杂度为O(n)

对于第二种已经找到要删除的及诶点，删除某个结点q需要知道其前驱结点，而单链表不支持直接获取前驱结点，为了找到前驱结点，还要从头遍历链表，直到p->next=q,说明p是q的前驱结点，所以单链表删除操作需要O(n)的时间复杂度，而双向链表只需要O(1)时间复杂度内就可以了。

如果我们希望在链表的某个指定结点前面插入一个结点，双向链表比单链表有很大的优势。双向链表可以在 O(1) 时间复杂度搞定，而单向链表需要 O(n) 的时间复杂度

对于一个有序链表，双向链表的按值查询的效率也要比单链表高一些。因为，我们可以记录上次查找的位置 p，每次查询时，根据要查找的值与 p 的大小关系，决定是往前还是往后查找，所以平均只需要查找一半的数据。

那就是用空间换时间的设计思想。当内存空间充足的时候，如果我们更加追求代码的执行速度，我们就可以选择空间复杂度相对较高、但时间复杂度相对很低的算法或者数据结构。相反，如果内存比较紧缺，比如代码跑在手机或者单片机上，这个时候，就要反过来用时间换空间的设计思路。

##链表的技巧

###技巧一：理解指针或引用的含义

**将某个变量赋值给指针，实际上就是将这个变量的地址赋值给指针，或者反过来说，指针中存储了这个变量的内存地址，指向了这个变量，通过这个指针就能找到这个变量。**

###技巧二：警惕指针丢失和内存泄漏

**插入节点时，一定要注意操作的顺序，**先将插入节点的next指针指向插入的后节点，然后在前插入节点的前节点的next指针指向插入节点。

**删除链表节点时，也一定要记得手动释放内存空间**，否则会出现内存泄漏的问题。（如果实现了自动管理内存的不用管）

###技巧三：利用哨兵简化实现难度

**针对链表的插入、删除操作，需要对插入第一个结点和删除最后一个结点的情况进行特殊处理。**

**哨兵结点**指的是在任何时候，不管链表是不是空，head指针（头结点）都会一直指向这个哨兵结点。这种有哨兵结点的链表叫**带头链表**，没有的叫**不带头链表**。

###技巧四：注意边界条件处理

链表为空，链表只有一个或两个结点，链表的头结点和尾结点是否正常。

##题

.如果字符串是通过单链表来存储的，那该如何来判断是一个回文串呢？相应的时间空间复杂度又是多少呢？
- “回文串”是一个正读和反读都一样的字符串，比如“level”或者“noon”等等就是回文串。

单链表反转
链表中环的检测
两个有序的链表合
并删除链表倒数第 n 个结点
求链表的中间结点